## 정리
##### 2025/03/25

### 화면 렌더링
> 리액트에서는 컴포넌트가 반환하는 JSX가 화면에 렌더링된다.
모든 UI 요소는 return 문 안에 포함되어야 하며, HTML 구조는 자바스크립트로 제어된다.

### 리액트의 데이터 중심 접근
> 리액트는 상태(state)를 기반으로 UI를 업데이트한다. (데이터 중심!)
화면에서 변경될 부분은 state로 관리해야 하며, 이를 통해 효율적으로 렌더링을 수행할 수 있다

### 객체 변경 주의 ❌ 불변성 
> 리액트에서는 `상태를 직접 수정하는 것이 아니라`, 상태를 업데이트하는 함수를 사용해야 한다

```
const [liked, setLiked] = useState(false);
setLiked(true); // 올바른 접근
this.state.liked = true; // 잘못된 접근
```



리액트에서의 배열 사용
리액트에서는 상태를 관리할 때 불변성을 유지하는 것이 중요


1. 배열을 직접 수정하는 메서드 (원본 배열 변경)
    - splice(): 배열의 특정 위치에서 요소를 추가하거나 제거. 
    - fill(): 배열의 모든 요소를 정해진 값으로 채움.
    - reverse(): 배열의 요소 순서를 반전시킴. 
    - sort(): 배열의 요소를 정렬함. 
2. 배열을 새롭게 만들어내는 메서드 (원본 배열 변경되지 않음)
    -  map(): 각 요소에 대해 주어진 함수를 호출하고, 새로운 배열을 반환.
    -  filter(): 주어진 조건을 만족하는 요소로 구성된 새로운 배열을 반환.
    - reduce(): 각 요소에 대해 주어진 함수를 실행하여 단일 값을 반환.
    - flat(): 다차원 배열을 평탄화하여 새로운 배열을 반환.
    - find(): 주어진 조건을 만족하는 첫 번째 요소를 반환.
    - findIndex(): 주어진 조건을 만족하는 첫 번째 요소의 인덱스를 반환.


컴포넌트를 분리하면 재사용성과 가독성이 높아지고, 유지보수와 협업이 쉬워진다
코드가 길어질 것 싶으면 컴포넌트를 분리하는 것이 좋음


<br/>

### 🔄 리액트 컴포넌트 렌더링이 발생하는 조건

렌더링은 다음 세 가지 중 하나가 변경될 때 발생한다

1. **state 변경**
2. **props 변경**
3. **부모 컴포넌트 리렌더링 시 자식 컴포넌트도 리렌더링**

렌더링이 발생하면 **컴포넌트가 다시 그려지며 "반짝임" 현상**이 생길 수 있다

불필요한 컴포넌트까지 렌더링되면 **성능 저하**로 이어질 수 있기 때문에 주의가 필요하다

### ⚠️ 렌더링 최적화 필요성

- 변화가 없는 상태에서도 `setState()`를 호출하면 렌더링이 발생한다

```
    onClickBtn = () => {
        this.setState({}); //실제 데이터 변화 없이도 렌더링 발생
    }
```

### 방법 1 ✅ `shouldComponentUpdate`로 렌더링 제어하기

리액트 클래스 컴포넌트에서 `shouldComponentUpdate()` 메서드를 오버라이드하면

렌더링 여부를 개발자가 직접 결정할 수 있다

```
    shouldComponentUpdate(nextprops, nextState, nextContext){
        //this.state.counter 현재 카운터 nextState.counter 미래 바뀌는 카운터
        if(this.state.counter !== nextState.counter){
            return true; // 상태가 바뀌었으므로 렌더링
        }
        return false; // 상태 변화 없으므로 렌더링 하지 않음
    }
```

### 방법 2 ✅ `PureComponent`

- `PureComponent`는 `shouldComponentUpdate` 메서드를 자동으로 구현해주는 컴포넌트입니다.
- 내부적으로 `props`와 `state`의 얕은 비교(shallow comparison)를 통해 리렌더링 여부를 판단합니다.

```
shouldComponentUpdate(nextProps, nextState, nextContext) {
    // 얕은 비교를 통해 true 또는 false 반환
}
```

### 장점

- 성능 최적화에 유리 (불필요한 리렌더링 방지)

### 단점

- 객체나 배열처럼 참조형 데이터가 있을 경우, 내부 내용이 바뀌었더라도 참조가 같으면 변경을 감지하지 못함
- 복잡한 구조의 상태 관리에는 적합하지 않을 수 있음